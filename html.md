### 简历相关

1. 自我介绍

   ```
   面试官你好，我叫陈莉媛，现在是西安工程大学计算机技术专业研二的在校生，我面试的职位是前端实习生。
   在本科的时候我开始接触前端，那会只会写简单的静态页面，我真正开始写代码是到了我的研究生阶段，在导师项目基础上，开始了我真正意义的前端开发之路。我起手的第一个项目是vue这个渐进式框架，vue上手快，没有太多的学习成本，开发效率也很好，但慢慢的我开始意识到，框架化开发的便利限制了我的思考，很多的原理和知识点都成了我看不到的盲区，所以目前也在各方面扫盲，主要着重于前端基础知识的学习，在html、css、jss的基础上延申和扩展，进一步提高自己。
   我性格开朗且真诚，能很快的融入团队，并找到自己的位置。
   很感谢CSIG又给我这次的面试机会，希望今天的面试，我能呈现最好的自己。
   以上是我的介绍。
   ```

   

2. 为什么选择做前端

   ```
   一方面是我的兴趣使然，通过我的第一个项目，让我见识了代码的神奇，也是第一次和我的同学用code去实现一个完整的东西，我就是很喜欢炫酷的动画和美丽优雅的页面,每完成一个界面我就会获得深深的成就感和满足感。另一方面是前端开发相对而言会更适合我，且市场需求呈阶梯式上升，就业前景不错。
   ```

   

3. 简历中项目

   1. 介绍项目

      ```
      智慧农业APP是去年暑假我们导师的一个项目，它是一个整合了农业在生产销售过程中的资源的APP，我主要负责的是移动端商城模块，功能类似于电商平台，对农产品进行销售。它的角色分为客户和商户，我实现的有商城首页页面、商品分类页面、商品详情页面、商品评论页面、对商品进行收藏、评论、加入购物车操作，在商户端实现商品的展示和分类，并对商品的管理，比如修改商品信息、对商品进行上下架操作。
      ```

      

   2. 项目中用到的技术栈

      ```
      项目使用的是uni-app跨平台框架，使用vue进行开发
      ```

   3. 遇到了哪些困难，是如何解决的

      ```
      因为在开发过程中，我们只是简单的功能实现，基本没有什么难点。出现的bug经过调试，以及查询别人的博客，基本都能解决。
      ```

      

   4. 上一次实习主要工作的内容和收获

      ```
      1.第一次尝试团队协作的工作氛围，因此非常想体验一些大厂规范的工作流程。
      2.对git的使用，团队开发对代码的管理非常重要。
      2.开拓眼界，原先的我对promise、async这类异步编程模式也只是一知半解，对项目的自动化构建并不熟悉，但通过实践收获了不少
      3.仔细看产品原型，查看接口文档。这很重要。需要仔细的查看原型，看看那些地方存在不合理的，需要及时找产品或相关负责人沟通，最终要确保对整个产品原型有很详细的了解。前端和后端都需要一份共同的接口文档，大家根据这个文档进行数据交互。确保前后端数据交互时不会有不一致的地方。
      4.解决问题能力。在开发过程中解决棘手的问题更加锻炼人，想写出又高效质量又高的代码很有难度。
      
      ```



### 计算机基础

#### 网络

##### 从浏览器地址栏输入 url 到显示页面的步骤

```
1.输入url后，会对地址进行解析
2.dns查询得到ip：
如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就用host
如果本地没有，就向dns域名服务器查询对应的ip
3.发起tcp/ip请求，建立tcp连接，开启网络线程发出HTTP请求
tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输（三次握手的目的是确保双方具有发送和接受消息的能力）
建立连接成功后，接下来就正式传输数据
4.从客户端发出http请求到服务器接收，中间会经过一系列的流程
从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。
服务端的接收就是反过来的步骤
5.服务器将响应报文通过tcp连接发送回浏览器
6.浏览器接受http数据包，解析HTML，构建DOM树-->解析CSS，生成CSS规则树-->合并DOM树和CSS规则，生成render树-->布局render树（Layout/reflow），负责各元素尺寸、位置的计算-->绘制render树（paint），绘制页面像素信息-->浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上
```



##### 知道http、https、http2吗？

- HTTP

```
HTTP 是一个无状态的协议。无状态是指客户机(Web 浏览器)和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息。HTTP 遵循请求(Request)/应答(Response)模型。客户机(浏览器)向服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。

主要特点如下：
简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST 等等。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。

数据格式灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由Content-Type 加以标记。
无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

无状态：HTTP 协议是无状态协议。无状态，是指协议对于事务处理没有记忆能力。无状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

支持 B/S 及 C/S 模式。
```

- http 2.0

```
http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的）

然后简述下http2.0与http1.1的显著不同点：

http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来
http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。
所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）

然后简述下http2.0的一些特性：

多路复用（即一个tcp/ip连接可以请求多个资源）
首部压缩（http头部压缩，减少体积）
二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）
服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）
请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）

```

- https

```
https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。

简单来看，https与http的区别就是： 在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析

一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）
```

#####  HTTP 和 HTTPS 的区别:

```
1.https协议需要到ca申请证书，一般免费证书很少，需要交费。
2.http的信息是明文传输，https 则是具有安全性的ssl加密传输协议。
3.http和https用的端口不一样，前者是80，后者是443。
4.http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全
5.资源消耗：和 HTTP 通信相比，HTTPS 通信会由于加解密处理消耗更多的 CPU 和内存资源。
```



#####  HTTP 基本格式

```
HTTP 请求格式
请求行：请求的方法 + 请求URL + 协议版本号。
请求头：客户端的Cookie和User-Agent就放在这里.
空白行CRLF
请求实体：比如客户端POST的数据就放在这里(对比:GET的数据放在请求行的URL里).

HTTP 响应格式
响应行：协议版本号 + 状态码 + 状态描述
响应头：服务器的Set-Cookie和Server信息就放在这里.
空白行CRLF
响应实体：比如服务器返回的HTML和JSON数据就放在这里

HTTP/1.0定义了三种请求方法：GET、POST 和 HEAD
HTTP/1.1，新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE 和 CONNECT。
```



##### 长连接与短连接

首先看`tcp/ip`层面的定义：

- 长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）
- 短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接

然后在http层面：

- `http1.0`中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接
- http1.1起，默认使用长连接，使用长连接会有这一行`Connection: keep-alive`，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接

注意： keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有



##### post/get区别

```
1、传送方式：get通过地址栏传输，post通过报文传输。
2、传送长度：get参数有长度限制（受限于url长度），而post无限制
3、GET和POST还有一个重大区别，简单的说：
GET产生一个TCP数据包；POST产生两个TCP数据包
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
4、对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
5、GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
```



##### http状态码

```
1**	信息，服务器收到请求，需要请求者继续执行操作
2**	成功，操作被成功接收并处理
3**	重定向，需要进一步的操作以完成请求
4**	客户端错误，请求包含语法错误或无法完成请求
5**	服务器错误，服务器在处理请求的过程中发生了错误

200——表明该请求被成功地完成，所请求的资源发送回客户端
304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存
400——客户端请求有错（譬如可以是安全模块拦截）
401——请求未经授权
403——禁止访问（譬如可以是未登录时禁止）
404——资源未找到
500——服务器内部错误
502--网关错误
503——服务不可用
```



#####  https请求的通信过程

       ```
1. 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 

2. 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器
（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）

3. 浏览器收到服务端的证书后
    
    - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示   
    - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密`Premaster secret`，发送给服务器。
    - 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-`session key`
    - 使用约定好的HASH算法计算握手消息，并使用生成的`session key`对消息进行加密，最后将之前生成的所有信息发送给服务端。 
    
4. 服务端收到浏览器的回复

    - 利用已知的加解密方式与自己的私钥进行解密，获取`Premaster secret`
    - 和浏览器相同规则生成`session key` 
    - 使用`session key`解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致
    - 使用`session key`加密一段握手消息，发送给浏览器
    
5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，
       ```

![image-20210413154959860](C:\Users\44833\AppData\Roaming\Typora\typora-user-images\image-20210413154959860.png)

##### tcp 和 udp 的区别

```
             UDP	TCP
是否连接	无连接	   面向连接
是否可靠	不可靠传输，不使用流量控制和拥塞控制	可靠传输，使用流量控制和拥塞控制
连接对象个数	支持一对一，一对多，多对一和多对多交互通信	只能是一对一通信
传输方式	面向报文	面向字节流
首部开销	首部开销小，仅8字节	首部最小20字节，最大60字节
适用场景	适用于实时应用（IP电话、视频会议、直播等）	适用于要求可靠传输的应用，例如文件传输

TCP提供全双工通信:
TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。
```

##### 计算机网络结构有那几层？http 是哪一层？tcp 呢？

```
http:应用层
tcp：传输层

五层因特网协议栈其实就是：

1.应用层(dns,http) DNS解析成IP并发送http请求
2.传输层(tcp,udp) 建立tcp连接（三次握手）
3.网络层(IP,ARP) IP寻址
4.数据链路层(PPP) 封装成帧
5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）
当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。

OSI七层框架：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等
会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程
```

##### tcp 三次握手四次挥手

```
三次握手：
1.客户端发送一个tcp的SYN=1,Seq=X的包到服务器端口
客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。

2.服务器发回SYN=1,ACK=X+1,Seq=Y的响应包
服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

3.客户端发送ACK=Y+1,Seq=Z
当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

四次挥手：
1.客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。
B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。

2.服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。

3.服务器B关闭与客户端A的连接，发送一个FIN给客户端A（。
B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。

4.客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）
A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。


为什么连接的时候是三次握手，关闭的时候却是四次握手？
答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
```

##### 强缓存和协商缓存

```
缓存可以简单的划分成两种类型：强缓存（200 from cache）与协商缓存（304）

区别简述如下：

强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求
协商缓存（304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存
对于协商缓存，使用Ctrl + F5强制刷新可以使得缓存无效

但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）
上述提到了强缓存和协商缓存，那它们是怎么区分的呢？

答案是通过不同的http头部控制
属于强缓存控制的：
（http1.1）Cache-Control/Max-Age
（http1.0）Pragma/Expires
属于协商缓存控制的：
（http1.1）If-None-Match/E-tag
（http1.0）If-Modified-Since/Last-Modified

http1.0中的缓存控制：

Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）
Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41
If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内

http1.1中的缓存控制：

Cache-Control：缓存控制头部，有no-cache、max-age等多种取值
Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算
If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。

刷新的三种方式：
1.浏览器url回车
浏览器发现缓存中有这个文件了，好了，就不发送任何请求了，直接去缓存中获取展现。（最快）
2.F5刷新
F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since：Wed, 10 Aug 2013 15:32:18 GMT然后服务器发现：诶，这个文件我在这个时间后还没修改过，不需要给你任何信息了，返回304就行了。于是浏览器获取到304后就去缓存中欢欢喜喜获取资源了。
3.Ctrl+F5
告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作...

```

##### Cookie和Session

```
cookie:
Http协议是⼀个⽆状态的协议，服务器不会知道到底是哪⼀台浏览器访问了它，因此需要⼀个标识⽤来让服务器区分不同的浏览器。cookie就是这个管理服务器与客户端之间状态的标识。
cookie的原理是，浏览器第⼀次向服务器发送请求时，服务器在response头部设置Set-Cookie字段，浏览器收到响应就会设置cookie并存储，在下⼀次该浏览器向服务器发送请求时，就会在request头部⾃动带上Cookie字段，服务器端收到该cookie⽤以区分不同的浏览器。当然，这个cookie与某个⽤户的对应关系应该在第⼀次访问时就存在服务器端，这时就需要session了。
session:
session是会话的意思，浏览器第⼀次访问服务端，服务端就会创建⼀次会话，在会话中保存标识该浏览器的信息。它与 cookie的区别就是session是缓存在服务端的，cookie 则是缓存在客户端，他们都由服务端⽣成，为了弥补Http协议⽆状态的缺陷。

Cookie有数量和大小的限制:
Cookie是HTTP头中的一个字段，虽然HTTP本身对这个字段并没有多少限制，但是Cookie最终还是存储在浏览器里，所以不同的浏览器对Cookie的存储都有一些限制。
解决方法：key用短字符；cookie中保存id，而不是名称；压缩一下。
```

##### 浏览器本地存储

在HTML5中提供了sessionStorage和localStorage。

sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，是会话级别的存储。

localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。



#### 数据库

1. 主键、外键和索引
1. 数据库范式
1. 数据库的数据类型
1. 事务的特性

#### Javascript

##### 基本数据类型 / 引用类型

```
数据类型：string,number,boolean,null,undefine  按值访问，存放栈内存中
引用类型：object  存放在堆内存中，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址
```

##### ES6新增数据类型，新特性掌握情况

```
Symbol 类型（基本）：每一个symbol值都是一个全局唯一的字符串，你永远不会知道它里面存的什么，symbol值可以作为对象的属性的键。

Set 类型（复杂）:对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用 
数组去重：Array.from(new Set(array)) // 装比写法 [... new Set(array)]

Map——本质上是键值对的集合，类似集合；可以遍历，方法很多，可以跟各种数据格式转换。 

WeakSet——成员都是对象；成员都是弱引用，可以被垃圾回收机制回收，可以 用来保存 DOM 节点，不容易造成内存泄漏； 

WeakMap——只接受对象最为键名（null 除外），不接受其他类型的值作为键 名；键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的；不能遍历，方法有 get、set、has、delete。
```

##### let var const的区别

```
let的特点：
1.存在块级作用域
2.不存在变量提升
3.暂时性死区：在块级作用域内，若存在用let命令声明的变量，则所在区块对该变量形成封闭作用域，也就是该变量无视外部的同名变量。而又因为不存在变量提升，所以在该区块中，不能在声明前使用该变量。
4.不允许重复声明：let不允许在相同作用域内，重复声明同一个变量
const：
const声明的变量不得改变值，一旦声明变量，就必须立即初始化
```

##### 数组常用操作

```
1.shift() 方法：
	用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。
2.unshift：
	用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。
3.join() 方法：
	以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。
4. pop() 方法：
	用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。如果数组为空则返回undefined
5.push() 方法：
	可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。
6.reverse() ：
	用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。
7.slice() 方法：
	用于提取目标数组的一部分，返回一个新数组，原数组不变。
	arr.slice(start, end);
8.splice() ：
	用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。
	arr.splice(start, count, addElement1, addElement2, ...);
9.concat() 方法：
	用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。
10.sort(orderfunction)：
	按指定的参数对数组进行排序
11.Array.isArray方法:
	返回一个布尔值，表示参数是否为数组。它可以弥补`typeof`运算符的不足。
12.valueOf方法:
	对象的通用方法，表示对该对象求值。
13.toString方法:
	对象的通用方法，数组的`toString`方法返回数组的字符串形式。
14.map()方法：
	将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。
15.forEach()方法：
	与`map`方法很相似，也是对数组的所有成员依次执行参数函数。但是，`forEach`方法不返回值
16.filter()方法：
	用于过滤数组成员，满足条件的成员组成一个新数组返回。
17.some()，every()
	返回一个布尔值，表示判断数组成员是否符合某种条件。
	它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。
	some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。
	every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。
18.reduce()，reduceRight()
	依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。
19.indexOf()，lastIndexOf()
	indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。
	indexOf方法还可以接受第二个参数，表示搜索的开始位置。
	lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。
```



##### js执行上下文 / 变量提升 / 作用域

- js执行上下文

  ​	执行上下文有且只有三类，全局执行上下文，函数上下文，与eval上下文

  - 全局执行上下文

    ```
    全局执行上下文只有一个，在客户端中一般由浏览器创建，也就是我们熟知的window对象，我们能通过this直接访问到它。
    全局对象window上预定义了大量的方法和属性，我们在全局环境的任意处都能直接访问这些属性方法，同时window对象还是var声明的全局变量的载体。我们通过var创建的全局对象，都可以通过window直接访问。
    ```

  - 函数执行上下文

    ```
    每当一个函数被调用时都会创建一个函数上下文；需要注意的是，同一个函数被多次调用，都会创建一个新的上下文.
    
    执行上下文栈(下文简称执行栈)也叫调用栈，执行栈用于存储代码执行期间创建的所有上下文，具有LIFO（Last In First Out后进先出，也就是先进后出）的特性。
    
    JS代码首次运行，都会先创建一个全局执行上下文并压入到执行栈中，之后每当有函数被调用，都会创建一个新的函数执行上下文并压入栈内；由于执行栈LIFO的特性，所以可以理解为，JS代码执行完毕前在执行栈底部永远有个全局执行上下文。
    ```

  - eval执行上下文

- 变量提升

  - JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。

  - JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。

- 作用域

  js中有全局作用域和函数作用域

  作用域链：

  ​		变量与函数的查找规则: 当我们调用一条数据的时候，js首先会在当前作用域中进行查找，如果找不到，就向上找到父级的作用域，如果在父级的作用域中也找不到，就继续向上查找，直到window的作用域。如果在window中也找不到，就报错了

##### bind,call,apply

call、apply、bind都是改变this指向的方法

- fn.call():

  当call方法执行的时候，内部处理了一些事情

  - 首先把要操作的函数中的this关键字变为call方法第一个传递的实参

  - 把call方法第二个及之后的实参获取到

  - 把要操作的函数执行，并且把第二个以后传递进来的实参传递给函数

    ```
    fn.call([this],[param]...)
    ```

- apply

  和call基本上一致，唯一区别在于传参方式。apply的参数是数组。

  ```
  foo.call(this, arg1,arg2,arg3) == foo.apply(this,arguments)==this.foo(arg1, arg2, arg3) == foo.bind(this,arg1,arg2,arg3)()
  ```

- bind

  和call基本上一致，bind 返回的是一个新的函数，你必须调用它才会被执行。





##### 深拷贝与浅拷贝

```
浅拷贝：创建一个新的对象，把原有的对象属性值，完整地拷贝过来。其中包括了原始类型的值，还有引用类型的内存地址。
实现方法：
1.Object.assign()
2.Array.prototype.concat()
3.Array.prototype.slice()
4.自定义函数
function simpleCopy(obj1) {
   var obj2 = Array.isArray(obj1) ? [] : {};
   for (let i in obj1) {
   obj2[i] = obj1[i];
  }
   return obj2;
}

深拷贝：拷贝所有的属性值，以及属性地址指向的值的内存空间。
实现方法：
1.JSON.parse(JSON.stringify())
function deepCopy(obj1){
    let _obj = JSON.stringify(obj1);
    let obj2 = JSON.parse(_obj);
    return obj2;
  }
2.递归
function deepCopy(obj1) {
      var obj2 = Array.isArray(obj1) ? [] : {};
      if (obj1 && typeof obj1 === "object") {
        for (var i in obj1) {
          if (obj1.hasOwnProperty(i)) {
            // 如果子属性为引用数据类型，递归复制
            if (obj1[i] && typeof obj1[i] === "object") {
              obj2[i] = deepCopy(obj1[i]);
            } else {
              // 如果是基本数据类型，只是简单的复制
              obj2[i] = obj1[i];
            }
          }
        }
      }
      return obj2;
    }
3.函数库lodash
var _=require('lodash');
var obj1 = {
	a:1,
	b:{f:{g:1}},
	c:[1.2.3]
};
var obj2 = _.cloneDeep(obj1);

 
区别：浅拷贝只是增加了一个指针指向已存在的内存地址，仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。深拷贝是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。
```



##### 闭包是什么

```
由于ES5中只有全局作用域和函数作用域，闭包就是函数执行时依赖变量作用域,而这个作用域是在函数定义时决定的,而不是函数调用时决定的，想要将函数体的变量在外部使用时，将返回值定义为一个函数，方便在外部调用
 常见三种用法：
 1.模仿块级作用域
 2.通过在函数中创建函数，并返回来延迟作用域链的存在时间
 3.创建私有变量
```



##### 数组去重

```
const arr = [1,2,3,4,4,3,2,1];
// 方法一：new Set ES6
return [...new Set(arr)]; // 这里又问到我...的用法，能够将对象字面量展开为多个元素，可以将剩余不定数的参数保存到一个数组中，代替argumens

// 方法二：双层for循环 (然后说这样性能不好，让我只用一层for循环的方法)
function unique(arr){
  var res=[];
  for (var i = 0; i < arr.length; i++) {
    for (var j = i+1; j < arr.length; j++) {
      if (arr[i] === arr[j]) {
        ++ i;
        j = i;
      }
    }
    res.push(arr[i]);
  }
  return res;
}

// 方法三：单层for循环 + indexOf
function unique(array){
    var res = [];
    for(var i = 0; i < array.length; i++) {
        //如果当前数组的第i项在当前数组中第一次出现的位置是i，才存入数组；否则代表是重复的
        if (array.indexOf(array[i]) === i) {
            res.push(array[i])
        }
    }
    return res;
}
// 方法三点三：或者这样
function unique(array){
    let res = [];
    for(var i = 0; i < array.length; i++) {
        if (res.indexOf(array[i]) === -1) {
            res.push(array[i]);
        }
    }
    return res;
}

// 方法四：面试官说如果可以容忍改变原有数组的情况下，怎么改进性能更好
function unique(array){
    // 注意这里一定要倒叙for循环，否则会出现问题
    for(var i = array.length - 1; i > 0; i--) { 
        if (array.indexOf(array[i]) !== i) {
            array.splice(i, 1);
        }
    }
    // 因为少声明一个变量，节省了内存空间（虽然可以忽略不计，但是面试嘛～）
    return array;
}
```



##### 原型链

```
每个函数都有一个 prototype 属性
每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性。
每一个JavaScript对象(除了 null )都具有的一个属性，叫proto，这个属性会指向该对象的原型
每个原型都有一个 constructor 属性指向关联的构造函数 实例原型指向构造函数

当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。

```



##### event loop 在浏览器和早些版本node中的异同

```
JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)
事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。

Node.js的单线程并不是真正的单线程，只是开启了单个线程进行业务处理（cpu的运算），同时开启了其他线程专门处理I/O。当一个指令到达主线程，主线程发现有I/O之后，直接把这个事件传给I/O线程，不会等待I/O结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是“单线程”、“异步I/O”。
I/O操作完之后呢？Node.js的I/O 处理完之后会有一个回调事件，这个事件会放在一个事件处理队列里头，在进程启动时node会创建一个类似于While(true)的循环，它的每一次轮询都会去查看是否有事件需要处理，是否有事件关联的回调函数需要处理，如果有就处理，然后加入下一个轮询，如果没有就退出进程，这就是所谓的“事件驱动”。这也从Node的角度解释了什么是”事件驱动”。
```



##### commonJS？ES Module？

我们都知道在早期JavaScript模块这一概念，都是通过script标签引入js文件代码。当然这写基本简单需求没有什么问题，但当我们的项目越来越庞大时，我们引入的js文件就会越多，这时就会出现以下问题：

- js文件作用域都是顶层，这会造成变量污染
- js文件多，变得不好维护
- js文件依赖问题，稍微不注意顺序引入错，代码全报错

为了解决以上问题`JavaScript`社区出现了`CommonJs`，**`CommonJs`是一种模块化的规范**，包括现在的`NodeJs`里面也采用了部分`CommonJs`语法在里面。那么在后来`Es6`版本正式加入了`Es Module`模块，这两种都是解决上面问题，那么都是解决什么问题呢。

- 解决变量污染问题，每个文件都是独立的作用域，所以不存在变量污染
- 解决代码维护问题，一个文件里代码非常清晰
- 解决文件依赖问题，一个文件里可以清楚的看到依赖了那些其它文件

CommonJs和Es Module的区别

- CommonJs
  - CommonJs可以动态加载语句，代码发生在运行时
  - CommonJs混合导出，还是一种语法，只不过不用声明前面对象而已，当我导出引用对象时之前的导出就被覆盖了
  - CommonJs导出值是拷贝，可以修改导出的值，这在代码出错时，不好排查引起变量污染

- Es Module

  - Es Module是静态的，不可以动态加载语句，只能声明在该文件的最顶部，代码发生在编译时

  - Es Module混合导出，单个导出，默认导出，完全互不影响
  - Es Module导出是引用值之前都存在映射关系，并且值都是可读的，不能修改
    

##### Promise

```
1.在JavaScript的世界中，所有代码都是单线程执行的。由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现,在请求到的成功回调函数里继续写函数，长此以往形成了回调地狱。

2.构造一个Promise实例需要给Promise构造函数传入一个函数。传入的函数需要有两个形参，两个形参都是function类型的参数。分别是resolve和reject。
Promise上还有then方法，then 方法就是用来指定Promise 对象的状态改变时确定执行的操作，resolve 时执行第一个函数（onFulfilled），reject时执行第二个函数（onRejected）。说到底，Promise 也还是使用回调函数，只不过是把回调封装在了内部，使用上一直通过 then 方法的链式调用，使得多层的回调嵌套看起来变成了同一层的，书写上以及理解上会更直观和简洁一些。

// ajax函数将返回Promise对象:
function ajax(method, url, data) {
    var request = new XMLHttpRequest();
    return new Promise(function (resolve, reject) {
        request.onreadystatechange = function () {
            if (request.readyState === 4) {
                if (request.status === 200) {
                    resolve(request.responseText);
                } else {
                    reject(request.status);
                }
            }
        };
        request.open(method, url);
        request.send(data);
    });
}
```

##### 箭头函数和普通函数的区别

```
箭头函数是匿名函数，不能作为构造函数，不能使用new
箭头函数不绑定arguments，取而代之用rest参数...解决
箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值
箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。
箭头函数没有原型属性
箭头函数不能当做Generator函数,不能使用yield关键字
```

##### 事件

	事件事件流就是事件从发生到执行结束的流程。
	
	事件流的三个阶段：捕获阶段，目标阶段，冒泡阶段。
	事件捕获阶段：事件开始由顶层元素触发，然后逐级向下传播，直到目标元素，依次执行其身上邦定的事件；
	事件目标阶段（处理阶段）：触发当前自身的事件；
	事件冒泡阶段：事件由目标元素先接收，然后逐级向上传播，达到最顶层元素，依次执行其身上绑定的事件。
	
	事件执行的流程是先捕获阶段→再目标元素阶段→最后冒泡阶段。


##### 判断数组

- 方法一： 使用instanceof方法
  原理是通过判断左操作数的对象的原型链上是否具有右操作数的构造函数的prototype属性

  ```
  var arr=[];
  console.log(arr instanceof Array) //返回true
  
  原理：
  function instance_of(L, R) {//L 表示左表达式，R 表示右表达式
   var O = R.prototype;
   L = L.__proto__;
   while (true) { 
     if (L === null) 
       return false; 
     if (O === L)  // 这里重点：当 O 严格等于 L 时，返回 true 
       return true; 
     L = L.__proto__; 
   } 
  }
  ```

- 方法二： 使用constructor方法
  constructor 属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数。

  ```
  console.log([].constructor == Array);  //true
  ```

- 方法三： 使用Object.prototype.toString.call(arr) === '[object Array]'方法

  ```
  function isArray(o) {
  　　return Object.prototype.toString.call(o);
  }
  var arr=[2,5,6,8];
  var obj={name:'zhangsan',age:25};
  var fn = function () {}
  console.log(isArray(arr)); //[object Array]
  console.log(isArray(obj)); //[object Object]
  console.log(isArray(fn));  //[object function]
  ```

- 方法四：ES5定义了Array.isArray:

  ```
  Array.isArray([]) //true
  ```

  

##### js垃圾回收机制

必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。

最基本的垃圾回收算法被称为**标记清除法（mark-and-sweep）**

工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。

工作流程：

​	垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。

另一种不常见的方法引用计数方式：

工作原理：跟踪记录每个值被引用的次数。当声明了一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减1，当这个值的引用次数为0的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为0的这些值。

用引用计数法会存在内存泄露



##### 原型继承

- 原型链继承

核心： 将父类的实例作为子类的原型

```
//两种
Son.prototype = Father.prototype;
Son.prototype = new Father();
```

- 借助构造函数继承

```
function Father () {
  this.name = "smd";
  this.age = 26
};
 
function Son () {
  Father.call(this)
  // Father.apply(this) 
}
// 弊端：Son只能继承Father自身的属性，而无法继承Father原型中的方法。
```

- 组合式继承

  ```
  function Father () {
    this.name = "smd";
    this.age = 26
  }
   
  Father.prototype.sayHi = function () {
    alert("hello")
  }
  function Son () {
    Father.call(this)
  }
   
  Son.prototype = new Father()
   
  var s = new Son();
  // 弊端：通过Father.call() 和 new Father() ,父类构造函数Father被调用了两次。
  ```

  参考：https://www.cnblogs.com/humin/p/4556820.html



##### 防抖节流

- 防抖——触发高频事件后 n 秒后函数只会执行一次，如果 n 秒内高频事件再 次被触发，则重新计算时间；

  ```
  function debounce(fn) 
  { 
  	let timeout = null // 创建一个标记用来存放定时器的返回值 
  	return function() { 
  		clearTimeout(timeout) // 每当用户输入的时候把前一个setTimeout clear 掉 
  		// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数 
  		timeout = setTimeout(() => { 
  			fn.apply(this, arguments) }, 500)
  	}
  }
  			
  function sayHi() { 
  	console.log('防抖成功')
  }
  var inp = document.getElementById('inp')
  inp.addEventListener('input', debounce(sayHi)) // 防抖
  ```

  

- 节流——高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执 行频率。 

  ```
  function throttle(fn) {
  	let canRun = true // 通过闭包保存一个标记 
  	return function() { 
  		if (!canRun) return // 在函数开头判断标记是否为 true，不为 true 则 return 
  		canRun = false // 立即设置为 false 
  		// 将外部传入的函数的执行放在 setTimeout 中
  		setTimeout(() => {  
  			fn.apply(this, arguments) 
  			canRun = true }, 500) 
  	}
  	// 最后在 setTimeout 执行完毕后再把标记设置为 true(关键) 表 示可以执行下一次循环了。当定时器没有执行的时候标记永远是 false，在开头被 return 掉
  }
  function sayHi(e) { 
  	console.log(e.target.innerWidth, e.target.innerHeight)
  }
  window.addEventListener('resize', throttle(sayHi))
  ```

##### 严格模式的特点

变量必须先声明后使用
函数的参数不能有同名属性，否则会报错
不能使用 with 语句
不能对只读属性赋值，否则会报错
不能使用前缀 0 表示八进制数，否则会报错
不能删除不可删除的属性，否则报错
不可删除变量 delete prop ，会报错，只能删除属性 delete global[prop]
eval 不会它的外层作用域引入变量
eval 和 arguments 不能被重新赋值
arguments 不会自动反映函数参数的变化
不能使用 arguments.callee
不能使用 arguments.caller
禁止 this 指向全局对象
不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈
增加了保留字（如 protected static interface）



#### CSS

##### 说出几种CSS display属性

```
1. position: relative;相对定位
1> 不影响元素本身特性（无论区块元素还是内联元素会保留其原本特性）
2> 不会使元素脱离文档流（元素原本位置会被保留，即改变位置也不会占用新位置）
3> 没有定位偏移量时对元素无影响（相对于自身原本位置进行偏移）
4>提升层级（用z-index样式的值可以改变一个定位元素的层级关系，从而改变元素的覆盖关系，值越大越在上面，z-index只能在position属性值为relative或absolute或fixed的元素上有效。）  （两个都为定位元素，后面的会覆盖前面的定位）

2. position: absolute;绝对定位
1> 使元素完全脱离文档流（在文档流中不再占位）
2> 使内联元素在设置宽高的时候支持宽高（改变内联元素的特性）
3> 使区块元素在未设置宽度时由内容撑开宽度（改变区块元素的特性）
4> 相对于最近一个有定位的父元素偏移（若其父元素没有定位则逐层上找，直到document——页面文档对象）
5> 相对定位一般配合绝对定位使用（将父元素设置相对定位，使其相对于父元素偏移）
6> 提升层级（同相对定位）

3. position: fixed;固定定位
  fixed生成固定定位的元素，相对于浏览器窗口进行定位。

4. position:static：默认值
默认布局。元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。

5. position: sticky 粘性定位
粘性定位，该定位基于用户滚动的位置。
它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。
注意: Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix 。

6. position: inherit
规定应该从父元素继承 position 属性的值。

7. posiyion: initial
设置该属性为默认值，详情查看CSS initial 关键字
initial 关键字用于设置 CSS 属性为它的默认值。
initial 关键字可用于任何 HTML 元素上的任何 CSS 属性。

```



#####  盒模型是什么

```
IE6盒子模型与W3C盒子模型。

文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。

CSS3中有个box-sizing属性可以控制盒子的计算方式，

content-box：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和。（W3C盒子模型）

border-box：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值。（IE6盒子模型）
```



#####  说出几种CSS基本单位

- px

相对单位，页面按精确像素展示

- em

相对单位，基于当前容器的大小，再乘以em的值得到最终的大小，可以理解为倍数。使用em设置段落中的字体大小和行距，在改变容器字体大小时，段落的字体大小和行距可以按比例缩放。

- rem

相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性。

- vw&vh

vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。
vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。

- vmin&vmax

vmin代表屏幕较短的一边，vmax代表屏幕较长的一边。

主要用于手机屏幕的旋转，vmin 和vmax 配合媒体查询(Media Query) 在响应式布局(Responsive)时很有用。



##### visibility: hidden - display: none的区别

```
普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置
进一步，display由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大
再进一步，当一个页面某个元素经常需要切换display时如何优化，一般会用复合层优化，或者要求低一点用absolute让其脱离普通文档流也行。然后可以将话题引到普通文档流，absolute文档流，复合图层的区别，
再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）
```



##### BFC

BFC全称是Block Formatting Context，即块格式化上下文。

BFC是一个具有特殊CSS样式的HTML盒子，比如div标签就经常用来当盒子用。

这些特殊样式如下，下面的样式只要满足一项，就说明这个盒子是BFC：

- float: left | right

- position: fixed | absolute

- display: inline-block | table-cell | table-caption | flex | inline-flex

- overflow: hidden | scroll | auto

  

  BFC是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。

BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。

利用BFC可以闭合浮动，防止与浮动元素重叠。



##### box-sizing：content-box/border-box

content-box：宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。

border-box：为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。



##### 实现子元素的垂直水平居中

- 行内元素：text-align + line-height=height
- 定宽定高：position: absolute + margin (通过绝对定位可以给元素设置距父元素上部top:50%，但是还没结束该元素还需要做一定的偏移才行，偏移量为该元素的一半高度margit-top:-height/2。)
- 不定高：position: absolute + translate (top: 50%;left: 50%;transform: translate(-50%,-50%);)
- flex布局：justify-content: center;align-items: center;
- table方式：display: table-cell; text-align: center; vertical-align: middle;



##### 三栏布局

- 使用flex：中间设置flex：1

- 使用absolute：左边left为0，右边right为0，中间设置left和right

  

##### flex布局

属性：

- flex-direction: row | row-reverse | column | column-reverse;

- flex-wrap: nowrap | wrap | wrap-reverse;

- flex-flow:是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap;

- justify-content: flex-start | flex-end | center | space-between | space-around;

- align-items: flex-start | flex-end | center | baseline | stretch;

- align-content: flex-start | flex-end | center | space-between | space-around | stretch;

  

  以下6个属性设置在项目上:

- order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。

- flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。

- flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小,负值对该属性无效。

- flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计主轴是否有多余空间。它的默认值为auto，即项目的本来大小。

- flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选.该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。

- align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

#### 网络安全

1. xss、csrf

   ```
   (1)同源策略
   同源策略在web应用的安全模型中是一个重要概念。不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。
   它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。
   同源内容：协议，域名，端口相同
   (2)xss
   XSS攻击全称跨站脚本攻击,是一种常见于 Web 应用中的计算机安全漏洞。恶意攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。比如获取用户的 Cookie、导航到恶意网站、携带木马等。
   XSS 如何防御？
   XSS 漏洞是由于对用户提交的数据没有经过严格的过滤处理造成的，所以防御的原则就是不相信用户输入的数据，对输入进行过滤，对输出进行编码。
   1、使用 XSS Filter：针对用户提交的数据进行有效的验证，只接受我们规定的长度或内容的提交，过滤掉其他的输入内容
   2、html 实体
   3、JavaScript编码
   (3)CSRF攻击攻击原理及过程如下：
   1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
   2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
   3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；
   4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
   5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 
     防御CSRF攻击：
     目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。
   ```

   

2. 性能优化

   https://segmentfault.com/a/1190000015635431

   https://www.jianshu.com/p/b54502d5ed0b

3. 跨域问题

   ```
   当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。
   
   jsonp:
   1) JSONP原理
   利用 <script> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。
   2) JSONP和AJAX对比
   JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）
   3) JSONP优缺点
   JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。
   4) JSONP的实现流程
   声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。
   创建一个<script>标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。
   服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是show('我不爱你')。
   最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。
   
   cors:
   浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。
   服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
   虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。
   复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。
   CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案
   
   Node中间件代理(两次跨域):
   实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。
   代理服务器，需要做以下几个步骤：
   接受客户端请求 将请求转发给服务器 拿到服务器响应数据 将响应转发给客户端
   
   nginx反向代理:
   实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。
   使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。
   实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。
   ```



#### 

