![image-20210219210344432](/Users/lili/Library/Application Support/typora-user-images/image-20210219210344432.png)



RESTful API是什么





跨域是什么？怎么解决跨域问题



![image-20210219212119561](/Users/lili/Library/Application Support/typora-user-images/image-20210219212119561.png)

状态







init



https://github.com/lodash



先锁住 再触发：t

raf请求动画帧















1.从浏览器地址栏输入 url 到显示页面的步骤

* DNS解析

* TCP连接

* 发送HTTP请求

* 服务器处理请求并返回HTTP报文

* 浏览器解析渲染页面

* 连接结束



* 输入url后，首先需要找到这个url域名的服务器ip,为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的html给浏览器，因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部样式，内部样式，内联样式构建一个CSS对象模型树CSSOM树，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用Cache-Control，在请求这些有设置了缓存的数据时，会先 查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304

2.知道http、https、http2吗？

* http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

  https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

  https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。

  (2)http和https的区别？

  http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。
  主要的区别如下：

  Https协议需要ca证书，费用较高。

  http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

  使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443

  http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

  (3)https协议的工作原理

  客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

  客户使用https url访问服务器，则要求web 服务器建立ssl链接。

  web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。

  客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。

  客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。

  web服务器通过自己的私钥解密出会话密钥。

  web服务器通过会话密钥加密与客户端之间的通信。

  (4)https协议的优点

  使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

  HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

  HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

  谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。

  (5)https协议的缺点

  https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。

  https缓存不如http高效，会增加数据开销。

  SSL证书也需要钱，功能越强大的证书费用越高。

  SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。

* Http2{url: https://zhuanlan.zhihu.com/p/26559480}

  * 首先补充一下，http和https的区别，相比于http,https是基于ssl加密的http协议

    简要概括：http2.0是基于1999年发布的http1.0之后的首次更新。

    提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比http1.0）

    允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。

    二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码

    首部压缩

    服务器端推送

  * http2.0的特性如下：

    1、内容安全，应为http2.0是基于https的，天然具有安全特性，通过http2.0的特性可以避免单纯使用https的性能下降

    2、二进制格式，http1.X的解析是基于文本的，http2.0将所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式编码，基于二进制可以让协议有更多的扩展性，比如引入了帧来传输数据和指令

    3、多路复用，这个功能相当于是长连接的增强，每个request请求可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面，另外多路复用中也支持了流的优先级，允许客户端告诉服务器那些内容是更优先级的资源，可以优先传输，


1. 列举5个http状态码并解释其含义

   100  Continue  继续。客户端应继续其请求

   101  Switching Protocols  切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议

   200  OK  请求成功。一般用于GET与POST请求

   201  Created  已创建。成功请求并创建了新的资源

   202  Accepted  已接受。已经接受请求，但未处理完成

   203  Non-Authoritative Information  非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本

   204  No Content  无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档

   205  Reset Content  重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域

   206  Partial Content  部分内容。服务器成功处理了部分GET请求

   300  Multiple Choices  多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择

   301  Moved Permanently  永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替

   302  Found  临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI

   303  See Other  查看其它地址。与301类似。使用GET和POST请求查看

   304  Not Modified  未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源

   305  Use Proxy  使用代理。所请求的资源必须通过代理访问

   306  Unused  已经被废弃的HTTP状态码

   307  Temporary Redirect  临时重定向。与302类似。使用GET请求重定向

   400  Bad Request  客户端请求的语法错误，服务器无法理解

   401  Unauthorized  请求要求用户的身份认证

   402  Payment Required  保留，将来使用

   403  Forbidden  服务器理解请求客户端的请求，但是拒绝执行此请求

   404  Not Found  服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面

   405  Method Not Allowed  客户端请求中的方法被禁止

   406  Not Acceptable  服务器无法根据客户端请求的内容特性完成请求

   407  Proxy Authentication Required  请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权

   408  Request Time-out  服务器等待客户端发送的请求时间过长，超时

   409  Conflict  服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突

   410  Gone  客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置

   411  Length Required  服务器无法处理客户端发送的不带Content-Length的请求信息

   412  Precondition Failed  客户端请求信息的先决条件错误

   413  Request Entity Too Large  由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息

   414  Request-URI Too Large  请求的URI过长（URI通常为网址），服务器无法处理

   415  Unsupported Media Type  服务器无法处理请求附带的媒体格式

   416  Requested range not satisfiable  客户端请求的范围无效

   417  Expectation Failed  服务器无法满足Expect的请求头信息

   500  Internal Server Error  服务器内部错误，无法完成请求

   501  Not Implemented  服务器不支持请求的功能，无法完成请求

   502  Bad Gateway  作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应

   503  Service Unavailable  由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中

   504  Gateway Time-out  充当网关或代理的服务器，未及时从远端服务器获取请求

   505  HTTP Version not supported  服务器不支持请求的HTTP协议的版本，无法完成处理

   

2. https请求的通信过程

   * 客户端向服务端发起建立**HTTPS请求**。
   * 服务器向客户端发送数字证书。
   * 客户端验证数字证书，证书验证通过后客户端生成会话密钥（双向验证则此处客户端也会向服务器发送证书）。
   * 服务器生成会话密钥（双向验证此处服务端也会对客户端的证书验证）。
   * 客户端与服务端开始进行加密会话。

   

1. tcp 和 udp 的区别

   （1）TCP是面向连接的，udp是无连接的即发送数据前不需要先建立链接。

   （2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。

   （3）TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。

   （4）TCP只能是1对1的，UDP支持1对1,1对多。

   （5）TCP的首部较大为20字节，而UDP只有8字节。

   （6）TCP是面向连接的可靠性传输，而UDP是不可靠的。

2. 计算机网络结构有那几层？http 是哪一层？tcp 呢？

   * 物理层，数据链路层，传输层，网络层，会话层，表示层，应用层
   * http是应用层，tcp是网络层

3. tcp 三次握手四次挥手{https://hit-alibaba.github.io/interview/basic/network/TCP.html}

   * TCP 提供一种**面向连接的、可靠的**字节流服务
   * 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP
   * TCP 使用校验和，确认和重传机制来保证可靠传输
   * TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
   * TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

   

   所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。

   三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 `connect()` 时。将触发三次握手。

   - 第一次握手(SYN=1, seq=x):

     客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。

     发送完毕后，客户端进入 `SYN_SEND` 状态。

   - 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):

     服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 `SYN_RCVD` 状态。

   - 第三次握手(ACK=1，ACKnum=y+1)

     客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1

     发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。

   三次握手的过程的示意图如下：

   ![three-way-handshake](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png)

   TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 `close()` 操作即可产生挥手操作。

   - 第一次挥手(FIN=1，seq=x)

     假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

     发送完毕后，客户端进入 `FIN_WAIT_1` 状态。

   - 第二次挥手(ACK=1，ACKnum=x+1)

     服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。

     发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。

   - 第三次挥手(FIN=1，seq=y)

     服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。

     发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。

   - 第四次挥手(ACK=1，ACKnum=y+1)

     客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。

     服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。

     客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。

   四次挥手的示意图如下：

   ![four-way-handshake](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png)

   

   

4. 强缓存和协商缓存{https://github.com/yiliang114/Blog/issues/6}

   这里说的缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。

   浏览器缓存主要有以下几个优点：

   1. 减少重复数据请求，避免通过网络再次加载资源，节省流量。
   2. 降低服务器的压力，提升网站性能。
   3. 加快客户端加载网页的速度， 提升用户体验。

   浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别：

   1. 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。
   2. 在 `chrome` 中强缓存（虽然没有发出真实的 `http` 请求）的请求状态码返回是 `200 (from cache)`；而协商缓存如果命中走缓存的话，请求的状态码是 `304 (not modified)`。 不同浏览器的策略不同，在 `Fire Fox `中，`from cache` 状态码是 304.

   > 其中 from cache 会分为 from disk cache 和 from memory cache. 从内存中获取最快，但是是 session 级别的缓存，关闭浏览器之后就没有了。
   > [![image.png](https://user-images.githubusercontent.com/11473889/57010212-249bda80-6c2e-11e9-8500-afe8c449e35f.png)](https://user-images.githubusercontent.com/11473889/57010212-249bda80-6c2e-11e9-8500-afe8c449e35f.png)

   #### 请求流程

   浏览器在第一次请求后缓存资源，再次请求时，会进行下面两个步骤：

   1. 浏览器会获取该缓存资源的 `header` 中的信息，根据 `response header` 中的 `expires` 和 `cache-control` 来判断是否命中强缓存，如果命中则直接从缓存中获取资源。
   2. 如果没有命中强缓存，浏览器就会发送请求到服务器，这次请求会带上 `IF-Modified-Since` 或者 `IF-None-Match`, 它们的值分别是第一次请求返回 `Last-Modified `或者 `Etag`，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段。

   借用网上的一张图片

   [![image.png](https://user-images.githubusercontent.com/11473889/57010205-16e65500-6c2e-11e9-8334-ce884274e529.png)](https://user-images.githubusercontent.com/11473889/57010205-16e65500-6c2e-11e9-8334-ce884274e529.png)

   #### 强缓存

   强缓存是根据返回头中的 `Expires` 或者 `Cache-Control` 两个字段来控制的，都是表示资源的缓存有效时间。

   - `Expires` 是 `http 1.0` 的规范，值是一个`GMT `格式的时间点字符串，比如 `Expires:Mon,18 Oct 2066 23:59:59 GMT` 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存。有一个缺点是，失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。而服务器的时间跟用户的实际时间是不一样是很正常的，所以 `Expires` 在实际使用中会带来一些麻烦。

   - ```
     Cache-Control 
     ```

     这个字段是

      

     ```
     http 1.1
     ```

      

     的规范，一般常用该字段的

      

     ```
     max-age
     ```

      

     值来进行判断，它是一个相对时间，比如 .

     ```
     Cache-Control:max-age=3600
     ```

      

     代表资源的有效期是 3600 秒。并且返回头中的

      

     ```
     Date
     ```

      

     表示消息发送的时间，表示当前资源在

      

     ```
     Date ~ Date +3600s 
     ```

     这段时间里都是有效的。不过我在实际使用中常常遇到设置了

      

     ```
     max-age
     ```

      

     之后，在

      

     ```
     max-age
     ```

      

     时间内重新访问资源却会返回

      

     ```
     304 not modified
     ```

      

     ，这是由于服务器的时间与本地的时间不同造成的。当然

      

     ```
     Cache-Control
     ```

      

     还有其他几个值可以设置， 不过相对来说都很少用了：

     - `no-cache` 不使用本地缓存。需要使用协商缓存。
     - `no-store`直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 `network` 中的 `disabled cache`。
     - `public` 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。
     - `private` 只能被终端用户的浏览器缓存。

   如果 `Cache-Control `与 `Expires` 同时存在的话， `Cache-Control` 的优先级高于 `Expires` 。

   #### 协商缓存

   协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到两对属性字段，都是成对出现的，即第一次请求的响应头带上某个字, `Last-Modified` 或者 `Etag`，则后续请求则会带上对应的请求字段 `If-Modified-Since`或者 `If-None-Match`，若响应头没有 `Last-Modified` 或者 `Etag` 字段，则请求头也不会有对应的字段。

   - `Last-Modified/If-Modified-Since` 二者的值都是GMT格式的时间字符串， `Last-Modified` 标记最后文件修改时间， 下一次请求时，请求头中会带上 `If-Modified-Since` 值就是 `Last-Modified` 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 如果文件没有变更则返回 `304 Not Modified` ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 `304 Not Modified` 的响应时，`response header` 中不会再添加的 `Last-Modified` 去试图更新本地缓存的 `Last-Modified`， 因为既然资源没有变化，那么 `Last-Modified` 也就不会改变；如果资源有变化，就正常返回返回资源内容，新的 `Last-Modified` 会在 `response header` 返回，并在下次请求之前更新本地缓存的 `Last-Modified`，下次请求时，`If-Modified-Since`会启用更新后的 `Last-Modified`。
   - `Etag/If-None-Match`， 值都是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过 `ETag`字段返回给浏览器，接收到 `If-None-Match` 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。与 `Last-Modified` 不一样的是，当服务器返回 `304 Not Modified` 的响应时，由于在服务器上`ETag` 重新计算过，`response header`中还会把这个 `ETag` 返回，即使这个 `ETag` 跟之前的没有变化。

   > HTTP中并没有指定如何生成 ETag，可以由开发者自行生成，哈希是比较理想的选择。

   #### 为什么要有 Etag

   `HTTP1.1` 中 `Etag` 的出现主要是为了解决几个 `Last-Modified` 比较难解决的问题：

   - 一些文件也许会周期性的更改，但是内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
   - 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，`If-Modified-Since` 能检查到的粒度是秒级的，使用 `Etag` 就能够保证这种需求下客户端在1秒内能刷新 N 次 cache。
   - 某些服务器不能精确的得到文件的最后修改时间。

   #### 优先级

   ```
    Cache-Control  > expires > Etag > Last-Modified
   ```

   #### 用户行为对缓存的影响

   ~~简单说就是 F5 刷新的时候，会暂时禁用强缓存~~

   经过对qq、fire fox 、safari 、chrome 这几个浏览器的访问同一个页面测试我发现，不同的浏览器在 F5 刷新的时候 ，同一个文件 qq 、fire fox 浏览器会返回 `304 Not Nodified`，在请求头中不携带 `Expires/Cache-Control`； 而 chrome 和 safari 刷新的时候，会返回 `200 from cache`， 没有真正发起请求，走强缓存。可见不同的浏览器反馈是不一致的，所以下面表格中"F5刷新"时 `Expires/Cache-Control` 会无效我认为是存在一定争议的。

   而 Ctrl + F5 强制刷新的时候，会暂时禁用强缓存和协商缓存。

   > 在写这篇博客时，对于我仅仅测试了一个浏览器之后便写了无效(因为网上大多数帖子写了无效，我也以为我验证通过了)，对指出这个问题的群友，表示感谢，希望其他人不会被我误导。

   | 用户操作        | Expires/Cache-Control              | Last-Modied/Etag |
   | --------------- | ---------------------------------- | ---------------- |
   | 地址栏回车      | 有效                               | 有效             |
   | 页面链接跳转    | 有效                               | 有效             |
   | 新开窗口        | 有效                               | 有效             |
   | 前进回退        | 有效                               | 有效             |
   | F5刷新          | 无效(有争议，不同浏览器反馈不一致) | 有效             |
   | Ctrl+F5强制刷新 | 无效                               | 无效             |

   #### 如何设置强缓存和协商缓存

   1. 后端服务器，写入代码逻辑中：

      ```
      res.setHeader('max-age': '3600 public')
      res.setHeader(etag: '5c20abbd-e2e8')
      res.setHeader('last-modified': Mon, 24 Dec 2018 09:49:49 GMT)
      ```

   2. `Nginx` 配置

      ```
      add_header Cache-Control "max-age=3600"
      ```

      一般来说，通过 nginx 静态资源服务器，会默认给资源带上强缓存、协商缓存的 header 字段。

      [![image.png](https://user-images.githubusercontent.com/11473889/57010188-fae2b380-6c2d-11e9-974e-6d2cb4eee219.png)](https://user-images.githubusercontent.com/11473889/57010188-fae2b380-6c2d-11e9-974e-6d2cb4eee219.png)

   #### 两个示例

   1. 如果在 `cache-control `定义的 `max-age` 时间之内，`js`, `css` 文件会走强缓存，`http` 状态码是 200， 跟服务器也并不会有交互。但是第一个文件 `index.html` 文件, 每次回车或者刷新都是状态码都是 304 ，因为它的请求头中默认每次都携带了 `Cache-Control: max-age=0` 。

      [![image.png](https://user-images.githubusercontent.com/11473889/57023165-e9b49980-6c63-11e9-9184-577bf610cc26.png)](https://user-images.githubusercontent.com/11473889/57023165-e9b49980-6c63-11e9-9184-577bf610cc26.png)

      [![image.png](https://user-images.githubusercontent.com/11473889/57023171-ede0b700-6c63-11e9-9f3a-7ba52004e009.png)](https://user-images.githubusercontent.com/11473889/57023171-ede0b700-6c63-11e9-9f3a-7ba52004e009.png)

   2. `js` `css` 文件 `cache-control `超时之后，重新按回车会走协商缓存，请求服务器发现资源没有改变，于是返回 304 ，浏览器从缓存中获取内容，从 `size` 中也可以看出端倪， 几百 B 的包不是静态资源的体积。

      [![image.png](https://user-images.githubusercontent.com/11473889/57023233-0c46b280-6c64-11e9-9ab2-69d727432034.png)](https://user-images.githubusercontent.com/11473889/57023233-0c46b280-6c64-11e9-9ab2-69d727432034.png)

   #### 三级缓存原理（大白话）

   最后总结一下浏览器的三级缓存原理：

   1. 先去内存看，如果有，直接加载
   2. 如果内存没有，择取硬盘获取，如果有直接加载
   3. 如果硬盘也没有，那么就进行网络请求
   4. 加载到的资源缓存到硬盘和内存

   

#### 数据库

1. 主键、外键和索引{https://zhuanlan.zhihu.com/p/64368422}

   **主键**是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许`NULL`。可以使用多个列作为联合主键，但联合主键并不常用。
   关系数据库通过**外键**可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。
   通过对数据库表创建**索引**，可以提高查询速度。通过创建唯一索引，可以保证某一列的值具有唯一性。数据库索引对于用户和应用程序来说都是透明的。

   

2. 数据库范式{https://blog.csdn.net/ljp812184246/article/details/50706596}

3. 数据库的数据类型{https://zhuanlan.zhihu.com/p/50891083}

   MySQL数据库的数据类型主要是分为数值型，日期时间型以及字符串型这三个大类

   

4. 事务的特性

   * 事务是应用程序中**一系列逻辑相关的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消**。也就是事务具有原子性：一个事务中的一系列的操作要么全部成功，要么一个都不做。
     事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消之前的所有操作。
   * 事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持久性（ Durability ）。这四个特性简称为 ACID 特性。
     1 、原子性
     事务是数据库的逻辑工作单位，不可分割，事务中包含的各操作要么都做，要么都不做
     2 、一致性
     事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。
     3 、隔离性
     一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。 事务的隔离级别有4级，可以查看这篇博客，[关于MySQL的事务处理及隔离级别](http://blog.sina.com.cn/s/blog_4c197d420101awhc.html)
     4 、持续性
     也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的，不能回滚。接下来的其它操作或故障不应该对其执行结果有任何影响。

   #### 

   Javascript

1. 基本数据类型 / 引用类型
   
   * 基本数据类型（Undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol）
   * 引用类型（Object)
   
   1. ES6新增数据类型，新特性掌握情况
   
      symbol；增加了let const；增加了剪头函数；
   
   2. let var的区别
   
      let 和 const 的使用方式和 var 没有区别,但是声明出的变量，使用规则有所不同，let 和 const 多了一些对变量的限制
   
      let和const声明变量的共同点：
   
      1，不允许重复声明变量
   
      2，有自己的块级作用域
   
      3，没有变量提升
   
      4，暂时性死区：作用域下，通过let声明的变量， 变量声明之前的区域，该变量不可用，这个区域就称作暂时性死区。
   
   3. 数组常用操作{https://javascript.ruanyifeng.com/stdlib/array.html}
   
      - [静态方法](https://javascript.ruanyifeng.com/stdlib/array.html#toc1)
      - [Array.isArray()](https://javascript.ruanyifeng.com/stdlib/array.html#toc2)
      - [实例方法](https://javascript.ruanyifeng.com/stdlib/array.html#toc3)
      - [valueOf()，toString()](https://javascript.ruanyifeng.com/stdlib/array.html#toc4)
      - [push()，pop()](https://javascript.ruanyifeng.com/stdlib/array.html#toc5)
      - [shift()，unshift()](https://javascript.ruanyifeng.com/stdlib/array.html#toc6)
      - [join()](https://javascript.ruanyifeng.com/stdlib/array.html#toc7)
      - [concat()](https://javascript.ruanyifeng.com/stdlib/array.html#toc8)
      - [reverse()](https://javascript.ruanyifeng.com/stdlib/array.html#toc9)
      - [slice()](https://javascript.ruanyifeng.com/stdlib/array.html#toc10)
      - [splice()](https://javascript.ruanyifeng.com/stdlib/array.html#toc11)
      - [sort()](https://javascript.ruanyifeng.com/stdlib/array.html#toc12)
      - [map()](https://javascript.ruanyifeng.com/stdlib/array.html#toc13)
      - [forEach()](https://javascript.ruanyifeng.com/stdlib/array.html#toc14)
      - [filter()](https://javascript.ruanyifeng.com/stdlib/array.html#toc15)
      - [some()，every()](https://javascript.ruanyifeng.com/stdlib/array.html#toc16)
      - [reduce()，reduceRight()](https://javascript.ruanyifeng.com/stdlib/array.html#toc17)
      - [indexOf()，lastIndexOf()](https://javascript.ruanyifeng.com/stdlib/array.html#toc18)
      - [链式使用
   
      
   
2. js执行上下文 / 变量提升 / 作用域

   执行上下文（execution context）是 JavaScript 中的一个基本部分，可以大致理解为当前被执行代码的环境或者作用域。变量提升（hoisting）也是一个基本概念，简单地说就是，我可以在变量和函数声明之前就使用它们。es5中作用域分为全局作用域和函数作用域，es6中新增了块及作用域。

   

3. bind,call,apply{都是调用一个函数, 其具有一个指定的this值，以及用的参数不同}

   * 都是可以改变 this 的指向的，但是这三个函数稍有不同
   * apply，以一个包含多个参数的数组作为参数
   * call，以若干个参数列表作为参数

4. 深拷贝与浅拷贝

   ### 参考回答：

   数组的浅拷贝：

   如果是数组，我们可以利用数组的一些方法，比如slice，concat方法返回一个新数组的特性来实现拷贝，但假如数组嵌套了对象或者数组的话，使用concat方法克隆并不完整，如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化，我们把这种复制引用的拷贝方法称为浅拷贝，

   深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也互相分离，修改一个对象的属性，不会影响另一个

   如何深拷贝一个数组

   1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是：

   ```
   var arr = ['old', 1, true, ['old1', 'old2'], {old: 1}]
   var new_arr = JSON.parse( JSON.stringify(arr) );
   console.log(new_arr);
   ```

   原理是JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象，通过这两个方法，也可以实现对象的深复制。

   但是这个方法不能够拷贝函数

   浅拷贝的实现：

   以上三个方法concat,slice ,JSON.stringify都是技巧类，根据实际项目情况选择使用，我们可以思考下如何实现一个对象或数组的浅拷贝，遍历对象，然后把属性和属性值都放在一个新的对象里即可

   ```
   var shallowCopy = function(obj) {
   ```

   // 只拷贝对象

   ```
   if (typeof obj !== ``'object'``) return;
   ```

   // 根据obj的类型判断是新建一个数组还是对象

   ```
   var newObj = obj instanceof Array ? [] : {};
   ```

   // 遍历obj，并且判断是obj的属性才拷贝

   ```
   for (var key in obj) {
   if (obj.hasOwnProperty(key)) {
   newObj[key] = obj[key];
   }
   }
   return newObj;
   }
   ```

   深拷贝的实现

   那如何实现一个深拷贝呢？说起来也好简单，我们在拷贝的时候判断一下属性值的类型，如果是对象，我们递归调用深拷贝函数不就好了~

   ```
   var deepCopy = function(obj) {``if (typeof obj !== ``'object'``) return;``var newObj = obj instanceof Array ? [] : {};``for (var key in obj) {``if (obj.hasOwnProperty(key)) {``newObj[key] = typeof obj[key] === ``'object'` `? deepCopy(obj[key]) : obj[key];``}``}``return newObj;``}
   ```

   

5. 闭包是什么

   MDN对闭包的定义是：闭包是指那些能够访问自由变量的函数，自由变量是指在函数中使用的，但既不是函数参数又不是函数的局部变量的变量，由此可以看出，闭包=函数+函数能够访问的自由变量，所以从技术的角度讲，所有JS函数都是闭包，但是这是理论上的闭包，还有一个实践角度上的闭包，从实践角度上来说，只有满足1、即使创建它的上下文已经销毁，它仍然存在，2、在代码中引入了自由变量，才称为闭包

   闭包的应用：

   模仿块级作用域。2、保存外部函数的变量。3、封装私有变量

   单例模式：

   ```
   var Singleton = (function(){
   var instance;
   var CreateSingleton = function (name) {
   this.name = name;
   if(instance) {
   return instance;
   }
   ```

   // 打印实例名字

   ```
   this.getName();
   // instance = this;
   // return instance;
   return instance = this;
   }
   ```

   // 获取实例的名字

   ```
   CreateSingleton.prototype.getName = function() {
   console.log(this.name)
   }
   return CreateSingleton;
   })();
   ```

   // 创建实例对象1

   ```
   var a = new Singleton(``'a'``);
   ```

   // 创建实例对象2

   [复制代码](https://www.nowcoder.com/tutorial/96/614ed46bbd9c483597ef89b8abfc9084#)

   ```
   var b = ``new` `Singleton(``'b'``);``console.log(a===b);
   ```

6. 数组去重{https://www.cnblogs.com/wisewrong/p/9642264.html}

   **
   一、测试模版**

   数组去重是一个老生常谈的问题，网上流传着有各种各样的解法

   为了测试这些解法的性能，我写了一个测试模版，用来计算数组去重的耗时

   [![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

   ```
   // distinct.js
   
   let arr1 = Array.from(new Array(100000), (x, index)=>{
       return index
   })
   
   let arr2 = Array.from(new Array(50000), (x, index)=>{
       return index+index
   })
   
   let start = new Date().getTime()
   console.log('开始数组去重')
   
   function distinct(a, b) {
       // 数组去重
   }
   
   console.log('去重后的长度', distinct(arr1, arr2).length)
   
   let end = new Date().getTime()
   console.log('耗时', end - start)
   ```

   [![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

   这里分别创建了两个长度为 10W 和 5W 的数组

   然后通过 distinct() 方法合并两个数组，并去掉其中的重复项

   数据量不大也不小，但已经能说明一些问题了

    

   **二、Array.filter() + indexOf**

   这个方法的思路是，将两个数组拼接为一个数组，然后使用 ES6 中的 [Array.filter()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) 遍历数组，并结合 indexOf 来排除重复项

   ```
   function distinct(a, b) {
       let arr = a.concat(b);
       return arr.filter((item, index)=> {
           return arr.indexOf(item) === index
       })
   }
   ```

   这就是我被吐槽的那个数组去重方法，看起来非常简洁，但实际性能。。。

   ![img](https://images2018.cnblogs.com/blog/1059788/201809/1059788-20180913183116577-917737589.png)

   是的，现实就是这么残酷，处理一个长度为 15W 的数组都需要 8427ms

    

   **三、双重 for 循环**

   最容易理解的方法，外层循环遍历元素，内层循环检查是否重复

   当有重复值的时候，可以使用 push()，也可以使用 splice()

   [![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

   ```
   function distinct(a, b) {
       let arr = a.concat(b);
       for (let i=0, len=arr.length; i<len; i++) {
           for (let j=i+1; j<len; j++) {
               if (arr[i] == arr[j]) {
                   arr.splice(j, 1);
                   // splice 会改变数组长度，所以要将数组长度 len 和下标 j 减一
                   len--;
                   j--;
               }
           }
       }
       return arr
   }
   ```

   [![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

   但这种方法占用的内存较高，效率也是最低的

    ![img](https://img2018.cnblogs.com/blog/1059788/201809/1059788-20180920125555003-1710467503.png)

    

   **四、for...of + includes()**

   双重for循环的升级版，外层用 for...of 语句替换 for 循环，把内层循环改为 includes()

   先创建一个空数组，当 includes() 返回 false 的时候，就将该元素 push 到空数组中 

   类似的，还可以用 indexOf() 来替代 includes()

   [![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

   ```
   function distinct(a, b) {
       let arr = a.concat(b)
       let result = []
       for (let i of arr) {
           !result.includes(i) && result.push(i)
       }
       return result
   }
   ```

   [![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

   这种方法和 filter + indexOf 挺类似

   只是把 filter() 的内部逻辑用 for 循环实现出来，再把 indexOf 换为 includes

   所以时长上也比较接近

    ![img](https://img2018.cnblogs.com/blog/1059788/201809/1059788-20180920142555361-480718309.png)

    

   **五、Array.sort()**

   首先使用 sort() 将数组进行排序

   然后比较相邻元素是否相等，从而排除重复项

   [![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

   ```
   function distinct(a, b) {
       let arr = a.concat(b)
       arr = arr.sort()
       let result = [arr[0]]
   
       for (let i=1, len=arr.length; i<len; i++) {
           arr[i] !== arr[i-1] && result.push(arr[i])
       }
       return result
   }
   ```

   [![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

   这种方法只做了一次排序和一次循环，所以效率会比上面的方法都要高

    ![img](https://img2018.cnblogs.com/blog/1059788/201809/1059788-20180920145432043-1219364650.png)

    

   **六、new Set()**

   ES6 新增了 [Set](http://es6.ruanyifeng.com/#docs/set-map) 这一数据结构，类似于数组，但 **Set 的成员具有唯一性**

   基于这一特性，就非常适合用来做数组去重了

   ```
   function distinct(a, b) {
       return Array.from(new Set([...a, ...b]))
   }
   ```

   那使用 Set 又需要多久时间来处理 15W 的数据呢？

   ![img](https://img2018.cnblogs.com/blog/1059788/201809/1059788-20180913192205800-2108081675.png)

   喵喵喵？？？ 57ms ？？我没眼花吧？？

   然后我在两个数组长度后面分别加了一个0，在 150W 的数据量之下...

   ![img](https://img2018.cnblogs.com/blog/1059788/201809/1059788-20180913192413388-12163612.png)

   居然有如此高性能且简洁的数组去重办法？！

    

   **七、for...of + Object**

   这个方法我只在一些文章里见过，实际工作中倒没怎么用

   首先创建一个空对象，然后用 for 循环遍历

   利用**对象的属性不会重复**这一特性，校验数组元素是否重复

   [![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

   ```
   function distinct(a, b) {
       let arr = a.concat(b)
       let result = []
       let obj = {}
   
       for (let i of arr) {
           if (!obj[i]) {
               result.push(i)
               obj[i] = 1
           }
       }
   
       return result
   }
   ```

   [![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

   当我看到这个方法的处理时长，我又傻眼了

   ![img](https://img2018.cnblogs.com/blog/1059788/201809/1059788-20180920144241545-1967025696.png)

   **15W 的数据居然只要 16ms ？？？ 比 Set() 还快？？？**

   然后我又试了试 150W 的数据量...

   ![img](https://img2018.cnblogs.com/blog/1059788/201809/1059788-20180920144417481-1569178817.png)

   

7. 原型链

   

8. event loop 在浏览器和早些版本node中的异同

   https://segmentfault.com/a/1190000013861128

9. commonJS？ES Module？

   https://github.com/kukuclass/kuku-junior/blob/feature/lili/homework/class.02.md

#### CSS

1. 说出几种CSS display属性
2. 盒模型是什么
3. 说出几种CSS基本单位
4. 说出几种定位方式
5. visibility: hidden - display: none的区别
6. 知道BFC吗？作用是什么

#### 网络安全

1. xss

   XSS：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在url地址的请求参数中，防御的话为cookie设置httpOnly属性，对用户的输入进行检查，进行特殊字符过滤

2. csrf

   CSRF：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求，比如用户登录了一个网站后，立刻在另一个ｔａｂ页面访问量攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库，防御方式的话：使用验证码，检查https头部的refer，使用token



## ● 描述一下XSS和CRSF攻击？防御方法？

### 参考回答：

XSS, 即为（Cross Site Scripting）, 中文名为跨站脚本, 是发生在目标用户的浏览器层面上的，当渲染DOM树的过程成发生了不在预期内执行的JS代码时，就发生了XSS攻击。大多数XSS攻击的主要方式是嵌入一段远程或者第三方域上的JS代码。实际上是在目标网站的作用域下执行了这段js代码。

CSRF（Cross Site Request Forgery，跨站请求伪造），字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。

XSS防御的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。也就是对提交的所有内容进行过滤，对url中的参数进行过滤，过滤掉会导致脚本执行的相关内容；然后对动态输出到页面的内容进行html编码，使脚本无法在浏览器中执行。虽然对输入过滤可以被绕过，但是也还是会拦截很大一部分的XSS攻击。

防御CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证

1. 性能优化

   *  web：

     降低请求量：合并资源，减少HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。

     加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。

     缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。

     渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline。

   * 减少HTTP请求

     使用内容发布网络（CDN）

     添加本地缓存

     压缩资源文件

     将CSS样式表放在顶部，把javascript放在底部（浏览器的运行机制决定）

     避免使用CSS表达式

     减少DNS查询

     使用外部javascript和CSS

     避免重定向

     图片lazyLoad





 

1. seo优化

#### 逻辑思维和算法

1. 当前只有一个5L的水壶和一个6L的水壶，如何从池塘中取出3L的水
2. 知道排序吗？描述一个你最熟悉的排序算法
3. 怎么实现对象的浅拷贝、深拷贝
4. 大数字相加，说出基本思路

